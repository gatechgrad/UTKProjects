<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>
The Title
</TITLE>
</HEAD>
<BODY>
The interactors package implements event-handling for Silhouette. Silhouette
tries to get the programmer to think in terms of behaviors on objects, rather
than in terms of low-level events. Hence Silhouette implements event-handling
by having the programmer write behavior objects that can be attached to
graphical objects. When an event occurs over a graphical object, 
Silhouette checks whether any of the behavior objects associated with
that graphical object wants to handle
the event, and if so, starts executing the appropriate behavior object.
All subsequent events are directed to that behavior object until it
indicates that it is finished. 
<p>
The advantage of the Silhouette model is that all the code associated with
a behavior is placed in one class and it is separated from all the other
behavior-handling code in the application. A second advantage of the
Silhouette model is that it mimics the way programmers attach behaviors
to Swing components (programmers attach listeners to Swing components and
Swing automatically directs events to the appropriate component).
A third advantage is that Silhouette automatically directs all events
to the behavior that is currently executing and suppresses all other
behaviors while this behavior executes.
<p>
The conventional Java event model does none of these things well.
First, it encourages programmers to mix code for several behaviors in the
same method. For example, it is common to find a MousePressed method that
handles a selection behavior, a text edit behavior, and a move/resize
behavior. The reason for this mixing is that programmers often write just
one listener to handle all the behaviors associated with an application.
Second, Java breaks event-handling into three different parts, mouse
handling, mouse motion handling, and keyboard handling. This means that
the code for a behavior often must be split among multiple classes. For
example, a text editing behavior typically requires both mouse handling
and keyboard handling and hence the code is split between two classes.
Third, Java's event listeners force the programmer to determine which
object an event should operate on. Finally, Java requires the programmer
to write the "traffic cop" code that suppresses other behaviors from
running once another behavior has started. For example, if a mouse motion
event is received and a text editing behavior is currently executing, the
traffic cop code must ensure that none of the behaviors which use mouse
motion events tries to start executing.
<p>
<hr>
<h1> Silhouette's Event Handling Models </h1>
<p>
Silhouette currently supports two different types of event-handling models:
<p>
<ol>
<li> The conventional Java listener model. Silhouette provides an abstract
     base class called SilJavaInteractor that implements Java's mouse
     listener, mouse motion listener, and key listener interfaces. A
     programmer can extend this class and override the appropriate methods
     in order to achieve the desired behavior. If the programmer uses
     this model, the programmer must remember to set a state variable
     that tells the Silhouette event handler when the behavior implemented
     by this class starts and when it stops. The documentation for the
     SilJavaInteractor class provides more information about this variable.
<p>
<li> Brad Myers' interactors model. Silhouette provides an abstract base
     class called SilInteractor that is based on Brad Myers' interactors
     model. SilInteractor implements a behavior
     as four separate methods:
     <p>
     <ol>
     <li> Start method: This method performs any processing that is required
          to initialize the behavior when it starts executing.
     <li> Running method: This method executes as the behavior is running
          and provides feedback to the user.
     <li> Stop method: This method performs any processing that is required
          once the behavior's stop event is received and may include 
	  calling an application callback procedure and making feedback
	  objects disappear.
     <li> Abort method: This method performs any processing that is
          required if the user aborts the behavior.
     </ol>
     A programmer can extend the SilInteractor class by overriding the
     appropriate methods in order to achieve the desired behavior. In
     addition, the programmer must provide a start and stop event so
     that the behavior knows when to start and stop.
</ol>
<p>
The two models are compatible so that the programmer can choose to
implement some behaviors using one model and some behaviors using
the other model. 
I personally prefer the interactors model because it I think it divides
the implementation of a behavior into its logical components, which makes
it easier for someone reading or maintaining the code to figure out what
the behavior accomplishes. A second advantage of the interactors model
is that the start and stop events are provided to the interactor's 
constructor, which makes it clear to the reader when the interactor starts
and stops. In contrast, a programmer using the SilJavaInteractor must
remember to write code that manipulates a state variable that is associated
with a SilJavaInteractor. My experience is that programmers often forget
to set this variable. Additionally, it is harder for a reader of the code
to determine which events start and stop the behavior. The disadvantages
of the interactors model are twofold: 1) the running method has to
use conditional code to distinguish among different types of events, and
2) Java events are passed to the
behavior methods as a java.awt.InputEvent rather than as a Mouse/KeyEvent
and therefore the events have to be cast to the appropriate event if the
programmer wants to extract information from them.
<p>
<hr>
<h1> Useful Things To Know </h1>
<p>
<ol>
<li> An interactor is added to a
Silhouette object using the addInteractor method.
In order to conserve space, it is better to create
one instance of an interactor and add it to multiple objects, rather than
creating multiple instances of an interactor and adding one instance to each
Silhouette object. For example, if there are 100 objects on a screen, it is
better to create one instance of a move interactor and add this instance
to each object then it is to create one instance of the move interactor for
each object on the screen.
<p>
<li> The programmer can use an interactor's getSelectedObject method to
retrieve the object that the interactor is currently operating on. 
<p>
<li> Sometimes the programmer will want to associate an interactor with
     a canvas and have the interactor find the object(s) it should operate on.
     A CanvasShape provides three methods---find, findLeaf, and 
     findShapes---to make it easier to find these objects.
<p>
<li> When no interactor is currently executing, Silhouette uses the
following algorithm to determine which interactor gets the event:
<p>
<ol>
<li> If the event is a mouse or key event, the event handler determines which
objects on the display contain the point at which the event occurred.
The interactors associated with the topmost object get the first crack at
the event. If none of the interactors wants to handle the event, then the
interactors associated with the composite object to which the topmost object
belongs gets passed the event. The event will continue to be passed up the
composite object hierarchy until either an object has an interactor that
starts on that event or until all objects in the hierarchy, including
the canvas object, is exhausted. If no interactors want the event,
the event goes unprocessed.
<p>
<li> If the event is a mouse motion event, the event is ignored. The rationale
  for ignoring such events is that many such events can get generated yet
  a behavior is unlikely to start on such an event.
</ol>
<p>
Two problems may seem apparent from the description of the above algorithm.
First, how would an interactor handling a key event know to which object the
event should be applied? The answer is that each canvas always saves the
(x,y) position from the last mouse or mouse motion event. It uses this
position to locate objects when key events occur (the code in an
interactor can access this position using the <tt>getX</tt> and
<tt>getY</tt> methods). 
<p>
The
second problem is what the programmer should do if they want a behavior to
start on a mousemotion event. The answer is that they can attach a
mousemotion listener to the JPanel associated with a canvas (the JPanel
can be retrieved using a CanvasShape's <tt>getSilPanel</tt> command). 
These listeners will
operate concurrently with the Silhouette event handler. In other words,
both these listeners and the Silhouette event handler will get the event.
That means that an interactor may consume the same event that one of the
programmer's listeners is consuming. For this reason, it is best to try
to implement a behavior as an interactor if at all possible.
</ol>
<p>
@see <a href="SilInteractor.html">SilInteractor</a>

</BODY>
</HTML>
